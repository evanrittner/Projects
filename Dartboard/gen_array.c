/*
** The project's main program. Generates a Python Numpy .npy file holding 
** the expected score of each point on a darboard, given the throw standard 
** deviation. For each point in the output array, it randomly generates 
** throws aimed at that point, following a bivariate normal distribution 
*/

#include <math.h>
#include <stdio.h>
#include <stdlib.h>

#define PI 3.141593
#define R1 0.037383
#define R2 0.093458
#define R3 0.55989 //alternate: 0.59813
#define R4 0.63551
#define R5 0.92352 //alternate: 0.96262

int slices[21] = {6, 13, 4, 18, 1, 20, 5, 12, 9, 14, 11, 8, 16, 7, 19, 3, 17, 2, 15, 10, 6};
unsigned char header[10] = {147, 78, 85, 77, 80, 89, 1, 0, 118, 0}; // numpy data file header


// Traditional dartboard score given x, y coordinates of throw on a r=1 dartboard
int score(double x, double y) {
    double r = sqrt(x * x + y * y);

    if       (r > 1)    return 0;
    else if  (r <= R1)  return 50;
    else if  (r <= R2)  return 25;

    double t = atan2(y, x);
    if (t < 0) 
        t += 2 * PI;
    
    int base = slices[(int) ((10.0 / PI) * t + 0.5)];

    if       (r < R3)   return base;
    else if  (r <= R4)  return 3 * base;
    else if  (r <= R5)  return base;
    else                return 2 * base;
}


// Determine the expected throw of a player aiming at the point (x, y) with throw
// standard deviation sigma. Do this by generating many throws (based on a multivariate
// normal distribution) and averaging the score. Scalar normal samples are first
// generated by the Box-Muller method, then transformed into the multivariate distribution.
double expected_score(double x, double y, double sigma, int count) {
    long total = 0; // more than 36M T20s would overflow an int
    double R, T;

    for (int i = 0; i < count; i++) {
        R = sqrt(-2 * log((double) rand() / RAND_MAX));
        T = 2 * PI * ((double) rand() / RAND_MAX);

        total += score(sigma * (R * cos(T)) + x, sigma * (R * sin(T)) + y);
    }

    return (double) total / count;
}


int main(int argc, char** argv) {
    // Parse command-line args
    // output filepath (required); sigma (default 0.4); resolution (px/unit) (default 250); statistical count (default 1000);
    // horizontal resolution (px) (default 500); vertical resolution (px) (default 500); x-center (default 0); y-center (default 0)
    char *end;

    double sigma   = (argc > 2 ? strtod(argv[2], &end) : 0.4);
    int resolution = (argc > 3 ? atoi(argv[3]) : 250);
    int count      = (argc > 4 ? atoi(argv[4]) : 1000);
    int x_px       = (argc > 5 ? atoi(argv[5]) : 500);
    int y_px       = (argc > 6 ? atoi(argv[6]) : 500);
    double x_c     = (argc > 7 ? strtod(argv[7], &end) : 0.0);
    double y_c     = (argc > 8 ? strtod(argv[8], &end) : 0.0);
    
    double step = 1.0 / (resolution);

    double xmin = x_c - step * x_px / 2;
    double xmax = x_c + step * x_px / 2;
    double ymin = y_c - step * y_px / 2;
    double ymax = y_c + step * y_px / 2;
    
    printf("file: %s; sigma: %f; px/unit: %d; step: %f; count: %d; range: [%f %f]x[%f %f]; x_px: %d; y_px: %d\n", argv[1], sigma, resolution, step, count, xmin, xmax, ymin, ymax, x_px, y_px);


    //Do calculations
    double *scores = malloc(x_px * y_px * sizeof(double));
    int index = 0;
    double x, y;
    
    do {
        y = step * (index / y_px) + ymin;

        do {
            x = step * (index % x_px) + xmin;
            scores[index++] = expected_score(x, y, sigma, count);
        } while (index % x_px != 0);

    } while (index < x_px * y_px);


    //Get file pointer, write the header and data
    FILE *fp = fopen(argv[1], "w");

    fwrite(header, 1, 10, fp);
    int written = fprintf(fp, "{'descr': '<f8', 'fortran_order': False, 'shape': (%d, %d), }", x_px, y_px);
    for (int i = 0; i < 117 - written; i++) fputc(' ', fp);
    fputc('\n', fp);
    
    fwrite(scores, sizeof(double), x_px * y_px, fp);


    // Clean up
    free(scores);
    fclose(fp);

    return 0;
}
